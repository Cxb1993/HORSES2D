   function Edge_AnalyticalX( self , xi , direction ) result( p )
      implicit none
      class(Edge_t), intent(in)           :: self
      real(kind=RP), intent(in)           :: xi
      integer      , intent(in)           :: direction
      real(kind=RP)                       :: p(2)
!     ------------------------------------------------------------
      real(kind=RP)                       :: correctedXi
      
      if (direction .eq. BACKWARD) then
        correctedXi = 1.0_RP - xi
      elseif (direction .eq. FORWARD) then
        correctedXi = xi
      end if 

      p = self % nodes(1) % n % X * (1.0_RP - correctedXi) + self % nodes(2) % n % X * correctedXi

   end function Edge_AnalyticalX

   function Edge_AnalyticaldS( self , xi , direction ) result( dS )
      implicit none
      class(Edge_t), intent(in)        :: self
      real(kind=RP), intent(in)        :: xi
      integer,       intent(in)        :: direction
      real(kind=RP)                    :: dS(2)
!     --------------------------------------------------------------

      associate( n1 => self % nodes(1) % n % X , &
                 n2 => self % nodes(2) % n % X )

         dS(1) = n2(2) - n1(2)
         dS(2) = -(n2(1) - n1(1))

      end associate

   end function Edge_AnalyticaldS

    function Edge_getX( self , iXi , direction ) result ( X ) 
      implicit none
      class(Edge_t), intent(in)                 :: self
      integer      , intent(in)                 :: iXi
      integer      , intent(in)                 :: direction
      real(kind=RP)                             :: X (NDIM)
!     -------------------------------------------------------------
      integer                                   :: correctediXi

      if (direction .eq. FORWARD) then
         correctediXi = iXi
      
      elseif (direction .eq. BACKWARD) then
         correctediXi = self % spA % N - iXi

      end if

      X = self % X(iX:iY,correctediXi)

   end function Edge_getX

   function Edge_getdX( self , iXi , direction ) result ( dX ) 
      implicit none
      class(Edge_t), intent(in)                 :: self
      integer      , intent(in)                 :: iXi
      integer      , intent(in)                 :: direction
      real(kind=RP)                             :: dX (NDIM)
!     -------------------------------------------------------------
      integer                                   :: correctediXi
      real(kind=RP)                             :: newsign

      if (direction .eq. FORWARD) then
         correctediXi = iXi
         newsign = 1.0_RP
      
      elseif (direction .eq. BACKWARD) then
         correctediXi = self % spA % N - iXi
         newsign = -1.0_RP

      end if

      dX = newsign * self % dX(iX:iY,correctediXi)

   end function Edge_getdX
