   subroutine Edge_SetCurve( self , points , order )
      implicit none
      class(Edge_t)                       :: self
      real(kind=RP), intent(in), optional :: points(:,:)
      integer      , intent(in), optional :: order
      integer                             :: p
      integer                             :: iXi

      self % x = reshape((/( self % nodes(1) % n % X * (1.0_RP - self % spA % xi(p)) + self % nodes(2) % n % X * self % spA % xi(p) , &
                                          p = 0 , self % spA % N)/),(/ NDIM , self % spA % N + 1 /) )

      associate( n1 => self % nodes(1) % n % X , n2 => self % nodes(2) % n % X )
         self % dS(iX,:) = n2(iY) - n1(iY)
         self % dS(iY,:) = -(n2(iX) - n1(iX))

         self % dX(iX,:) = n2(iX) - n1(iX)
         self % dX(iY,:) = n2(iY) - n1(iY)

         do iXi = 0 , self % spA % N
            self % n(iX:iY,iXi) = self % dS (iX:iY,iXi) / (norm2(self % dS(iX:iY,iXi)))
         end do

      end associate
   
   
      associate( N => self % spA % N )

      do iXi = 0 , N
       self % T(1:NCONS,1:NCONS,iXi) = reshape((/ 1.0_RP , 0.0_RP             , 0.0_RP            , 0.0_RP , &
                                                0.0_RP , self % dS(iX,iXi)  , self % dS(iY,iXi) , 0.0_RP , &
                                                0.0_RP , -self % dS(iY,iXi) , self % dS(iX,iXi) , 0.0_RP , &
                                                0.0_RP , 0.0_RP             , 0.0_RP            , self % dS(iX,iXi)* self % dS(iX,iXi) + self % dS(iY,iXi) * self % dS(iY,iXi)/),(/NCONS,NCONS/),ORDER=(/2,1/)) 

       associate ( dS_square => self % T(IRHOE,IRHOE,iXi) )
       self % Tinv(1:NCONS,1:NCONS,iXi) = reshape((/ dS_square , 0.0_RP            , 0.0_RP             , 0.0_RP , &
                                                   0.0_RP , self % dS(iX,iXi) , -self % dS(iY,iXi) , 0.0_RP , &
                                                   0.0_RP , self % dS(iY,iXi) , self % dS(iX,iXi)  , 0.0_RP , &
                                                   0.0_RP , 0.0_RP            , 0.0_RP             , 1.0_RP /),(/NCONS,NCONS/),ORDER=(/2,1/)) / dS_square 
       end associate
      end do

      end associate


   end subroutine Edge_SetCurve


   function Edge_AnalyticalX( self , xi , direction ) result( p )
      implicit none
      class(Edge_t), intent(in)           :: self
      real(kind=RP), intent(in)           :: xi
      integer      , intent(in), optional :: direction
      real(kind=RP)                       :: p(2)
!     ------------------------------------------------------------
      real(kind=RP), allocatable          :: correctedXi
      
      if (present(direction)) then

         allocate(correctedXi)

         if (direction .eq. BACKWARD) then
           correctedXi = 1.0_RP - xi
         elseif (direction .eq. FORWARD) then
           correctedXi = xi
         end if 
   
         p = self % nodes(1) % n % X * (1.0_RP - correctedXi) + self % nodes(2) % n % X * correctedXi
   
      else 
         p = self % nodes(1) % n % X * (1.0_RP - xi) + self % nodes(2) % n % X * xi

      end if

   end function Edge_AnalyticalX

   function Edge_AnalyticaldX( self , xi , direction ) result( p )
      implicit none
      class(Edge_t), intent(in)           :: self
      real(kind=RP), intent(in)           :: xi
      integer      , intent(in), optional :: direction
      real(kind=RP)                       :: p(2)
!     ------------------------------------------------------------

      if (present(direction)) then
         p = real(direction,kind=RP) * ( self % nodes(2) % n % X - self % nodes(1) % n % X )
      else
         p = ( self % nodes(2) % n % X - self % nodes(1) % n % X )
      end if

   end function Edge_AnalyticaldX

   function Edge_AnalyticaldS( self , xi , direction ) result( dS )
      implicit none
      class(Edge_t), intent(in)           :: self
      real(kind=RP), intent(in)           :: xi
      integer,       intent(in), optional :: direction
      real(kind=RP)                       :: dS(2)
!     --------------------------------------------------------------

      associate( n1 => self % nodes(1) % n % X , &
                 n2 => self % nodes(2) % n % X )

         dS(1) = n2(2) - n1(2)
         dS(2) = -(n2(1) - n1(1))

      end associate

   end function Edge_AnalyticaldS

    function Edge_getX( self , iXi , direction ) result ( X ) 
      implicit none
      class(Edge_t), intent(in)                 :: self
      integer      , intent(in)                 :: iXi
      integer      , intent(in), optional       :: direction
      real(kind=RP)                             :: X (NDIM)
!     -------------------------------------------------------------
      integer, allocatable                      :: correctediXi

      if (present(direction)) then

         allocate(correctediXi) 

         if (direction .eq. FORWARD) then
            correctediXi = iXi
         
         elseif (direction .eq. BACKWARD) then
            correctediXi = self % spA % N - iXi
   
         end if
   
         X = self % X(iX:iY,correctediXi)
   
      else 

         X = self % X(iX:iY,iXi)

      end if

   end function Edge_getX

   function Edge_getdX( self , iXi , direction ) result ( dX ) 
      implicit none
      class(Edge_t), intent(in)                 :: self
      integer      , intent(in)                 :: iXi
      integer      , intent(in), optional       :: direction
      real(kind=RP)                             :: dX (NDIM)
!     -------------------------------------------------------------
      integer, allocatable                      :: correctediXi

      if (present(direction)) then
   
         allocate(correctediXi)

         if (direction .eq. FORWARD) then
            correctediXi = iXi
         
         elseif (direction .eq. BACKWARD) then
            correctediXi = self % spA % N - iXi
   
         end if
   
         dX = real(direction,kind=RP) * self % dX(iX:iY,correctediXi)
   
      else
  
         dX = real(direction,kind=RP) * self % dX(iX:iY,iXi)
 
      end if

   end function Edge_getdX

   function Edge_getdS( self , iXi , direction ) result ( dS ) 
      implicit none
      class(Edge_t), intent(in)                 :: self
      integer      , intent(in)                 :: iXi
      integer      , intent(in), optional       :: direction
      real(kind=RP)                             :: dS (NDIM)
!     -------------------------------------------------------------
      integer, allocatable                      :: correctediXi

      if (present(direction)) then
   
         allocate(correctediXi)

         if (direction .eq. FORWARD) then
            correctediXi = iXi
         
         elseif (direction .eq. BACKWARD) then
            correctediXi = self % spA % N - iXi
   
         end if
   
         dS = self % dS(iX:iY,correctediXi)
   
      else
  
         dS = self % dS(iX:iY,iXi)
 
      end if



   end function Edge_getdS

