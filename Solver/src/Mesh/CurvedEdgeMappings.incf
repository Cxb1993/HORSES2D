  subroutine CurvilinearEdge_SetCurve( self , points , order )
     use InterpolationAndDerivatives
     use MatrixOperations
     implicit none
     class(CurvedBdryEdge_t)                            :: self
     real(kind=RP)               , intent(in), optional :: points(:,:)
     integer                     , intent(in), optional :: order
!    -----------------------------------------------------------------------------
     real(kind=RP), allocatable                         :: CGLnodes(:)
     real(kind=RP), allocatable                         :: CGLintermediate(:)             ! These nodes are needed since curve order .ne. interpolation order
     real(kind=RP), allocatable                         :: Xintermediate(:,:)
     real(kind=RP), allocatable                         :: T(:,:)
     real(kind=RP), allocatable                         :: wb(:) 
     integer                                            :: node
     integer                                            :: iXi

     if ( present(points) .and. present(order) ) then

      associate ( N => self % spA % N ) 

        allocate( CGLnodes(0 : order ) )
        allocate( CGLintermediate(0 : N ) )

        CGLnodes = reshape ( (/(0.5_RP + 0.5_RP*cos(PI*(order - node)/(1.0_RP*order)),node = 0,order)/),(/order+1/) )
        CGLintermediate = reshape ( (/(0.5_RP + 0.5_RP*cos(PI*(N - node)/(1.0_RP*N)),node = 0,N)/),(/N+1/) )

        allocate( Xintermediate(NDIM , 0:N) )
  
        allocate( wb ( 0 : order ) )
        allocate( T ( 0 : N , 0 : order ) )
  
        call BarycentricWeights( N = order , x = CGLnodes , w = wb )
        call PolynomialInterpolationMatrix( N = order , M = N , oldNodes = CGLnodes, weights = wb, newNodes = CGLintermediate , T = T )
!
!       Compute intermediate points
!       ---------------------------
        Xintermediate = Mat_x_Mat_F ( A = points , B = T , rowC = NDIM , colC = N+1, trB = .true. ) 

        deallocate( wb , T )
   
        allocate ( wb ( 0 : N         )  ) 
        allocate ( T  ( 0 : N , 0 : N )  ) 

        call BarycentricWeights( N = N , x = CGLintermediate , w = wb )
        call PolynomialInterpolationMatrix( N = N , M = N , oldNodes = CGLintermediate, weights = wb, newNodes = self % spA % xi , T = T)
  
!       Compute points
!       --------------
        self % X  = Mat_x_Mat_F ( A = Xintermediate  , B = T , rowC = NDIM , colC = N+1 , trB = .true. ) 

!       Compute tangent vector
!       ----------------------
        self % dX = Mat_x_Mat_F ( A = self % X , B = self % spA % D , rowC = NDIM , colC = N+1 , trB = .true. ) 

!       Compute normal vector
!       ---------------------
        self % dS(iX,:) =   self % dX(iY,:)
        self % dS(iY,:) = - self % dX(iX,:)

         do iXi = 0 , self % spA % N
            self % n(iX:iY,iXi) = self % dS (iX:iY,iXi) / (norm2(self % dS(iX:iY,iXi)))
         end do
  
!
!       Compute rotation matrices
!       -------------------------
        do iXi = 0 , N
            self % T(1:NCONS,1:NCONS,iXi) = reshape((/ 1.0_RP , 0.0_RP             , 0.0_RP            , 0.0_RP , &
                                                0.0_RP , self % dS(iX,iXi)  , self % dS(iY,iXi) , 0.0_RP , &
                                                0.0_RP , -self % dS(iY,iXi) , self % dS(iX,iXi) , 0.0_RP , &
                                                0.0_RP , 0.0_RP             , 0.0_RP            , self % dS(iX,iXi)* self % dS(iX,iXi) + self % dS(iY,iXi) * self % dS(iY,iXi)/),(/NCONS,NCONS/),ORDER=(/2,1/)) 

            associate ( dS_square => self % T(IRHOE,IRHOE,iXi) )
            self % Tinv(1:NCONS,1:NCONS,iXi) = reshape((/ dS_square , 0.0_RP            , 0.0_RP             , 0.0_RP , &
                                                   0.0_RP , self % dS(iX,iXi) , -self % dS(iY,iXi) , 0.0_RP , &
                                                   0.0_RP , self % dS(iY,iXi) , self % dS(iX,iXi)  , 0.0_RP , &
                                                   0.0_RP , 0.0_RP            , 0.0_RP             , 1.0_RP /),(/NCONS,NCONS/),ORDER=(/2,1/)) / dS_square 
            end associate
        end do

        end associate

     else

         print*, "Missing curve interpolation data"
         stop "Stopped."

     end if

  end subroutine CurvilinearEdge_SetCurve

  function Curvilinear_InterpolantX( self , xi , direction ) result( p )
      use MatrixOperations
      implicit none
      class(CurvedBdryEdge_t), intent (in)           :: self
      real(kind=RP),           intent (in)           :: xi
      integer      ,           intent (in), optional :: direction
      real(kind=RP)                                  :: p(NDIM)
!     ------------------------------------------------------------
      real(kind=RP)                                  :: correctedXi
      integer                                        :: dir
      
      if (present(direction)) then
         dir = direction
      else 
         dir = FORWARD
      end if

      if (dir .eq. BACKWARD) then
        correctedXi = 1.0_RP - xi
      elseif (dir .eq. FORWARD) then
        correctedXi = xi
      end if 
       
      p = MatrixTimesVector_F( self % X , self % spA % lj(correctedXi) , size(self % X ,1 ))
      
  end function Curvilinear_InterpolantX

  function Curvilinear_InterpolantdS( self , xi , direction ) result( dS )
      use MatrixOperations
      implicit none
      class(CurvedBdryEdge_t), intent (in)           :: self
      real(kind=RP),           intent (in)           :: xi
      integer,                 intent (in), optional :: direction
      real(kind=RP)                                  :: dS(NDIM)
!     --------------------------------------------------------------
      real(kind=RP)                        :: correctedXi
      integer                                      :: dir

      if (present(direction)) then
         dir = direction
      else 
         dir = FORWARD
      end if

      if (dir .eq. BACKWARD) then
        correctedXi = 1.0_RP - xi
      elseif (dir .eq. FORWARD) then
        correctedXi = xi
      end if 
        
      dS = MatrixTimesVector_F( self % dS , self % spA % lj(correctedXi) , NDIM )

   end function Curvilinear_InterpolantdS

  function Curvilinear_InterpolantdX( self , xi , direction ) result( dX )
      use MatrixOperations
      implicit none
      class(CurvedBdryEdge_t), intent (in)           :: self
      real(kind=RP),           intent (in)           :: xi
      integer      ,           intent (in), optional :: direction
      real(kind=RP)                                  :: dX(NDIM)
!     ------------------------------------------------------------
      integer                                        :: dir
      real(kind=RP)                                  :: correctedXi
      
      if (present(direction)) then
         dir = direction
      else 
         dir = FORWARD
      end if

      if (dir .eq. BACKWARD) then
        correctedXi = 1.0_RP - xi
      elseif (dir .eq. FORWARD) then
        correctedXi = xi
      end if 
   
      dX = real(dir , kind=RP) * MatrixTimesVector_F( self % dX , self % spA % lj(correctedXi) , NDIM)

  end function Curvilinear_InterpolantdX

 
