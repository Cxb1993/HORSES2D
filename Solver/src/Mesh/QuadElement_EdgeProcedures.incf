        subroutine Edge_LinkWithElements( self , el1 , el2 , elb)
            use InterpolationAndDerivatives
            use MatrixOperations
            implicit none
            class(Edge_p)                          :: self
            class(QuadElement_t), target, optional :: el1
            class(QuadElement_t), target, optional :: el2
            class(QuadElement_t), target, optional :: elb
!           ----------------------------------------------------------------------
            integer                        :: nodesID(POINTS_PER_EDGE)
            integer                        :: nodesEl1(POINTS_PER_QUAD)
            integer                        :: nodesEl2(POINTS_PER_QUAD)
            integer                        :: nodesElb(POINTS_PER_QUAD)
            integer                        :: node
            integer(kind=1)                :: edgePosition
            integer(kind=1)                :: edgeDirection
            logical                        :: needsInversion

            do node = 1 , POINTS_PER_EDGE
               nodesID(node) = self % f % nodes(node) % n %ID
            end do

            if (present(el1) .and. present(el2) .and. (.not. present(elb)) ) then             ! Interior edge            

               allocate ( self % f % storage ( QUADS_PER_EDGE ) ) 

!              Gather all four nodes in both elements
!              --------------------------------------
               do node = 1 , POINTS_PER_QUAD 
                  nodesEl1(node)  = el1 % nodes(node) % n % ID 
                  nodesEl2(node)  = el2 % nodes(node) % n % ID
               end do

!              Search for the edge in element1: forced to be always the LEFT element, and FORWARD
!              ----------------------------------------------------------------------------------
               call searchEdge( nodesEl = nodesEl1 , nodesEdge = nodesID , needsInversion = needsInversion , edgePosition = edgePosition , edgeDirection = edgeDirection)
!
!              Link the items
!              --------------
               el1  % edges     ( edgePosition ) % f => self % f
               self % f % quads ( LEFT         ) % e => el1

               el1  % edgesDirection   ( edgePosition )  = FORWARD
               el1  % quadPosition     ( edgePosition )  = LEFT
               self % f % edgeLocation ( LEFT         )  = edgePosition
!
!              Adapt the edge to the LEFT element
!              ----------------------------------
               if ( needsInversion ) then
                  if ( (edgePosition .eq. EBOTTOM) .or. (edgePosition .eq. ERIGHT) ) then
                     call self % f % Invert ( changeSigndS = .true. )
                     nodesID = nodesID(2:1:-1)         

                  else
                     call self % f % Invert ( changeSigndS = .false. )
                     nodesID = nodesID(2:1:-1)         

                  end if

               else     ! Change the sign of the normal if is TOP or LEFT
                  if ( ( edgePosition .eq. ETOP) .or. (edgePosition .eq. ELEFT) ) then
                     self % f % n = -self % f % n

                  end if

               end if

               call self % f % storage (LEFT) % Initialize ( el1 % spA )
!
!              State whether a polynomial transformation is needed or not.
!              -----------------------------------------------------------
               if ( el1 % spA % N .eq. self % f % spA % N ) then
                  self % f % transform (LEFT) = .false.
            
               else
                  self % f % transform (LEFT) = .true.
                  self % f % Nlow  = el1 % spA % N
!
!                 Computing the forward matrix: From the element degree to the edge
!                 -----------------------------------------------------------------
                  allocate ( self % f % T_forward   ( 0:self % f % spA % N , 0:el1 % spA % N )  ) 
                  call PolynomialInterpolationMatrix( el1 % spA % N , self % f % spA % N , el1 % spA % xi , el1 % spA % wb , self % f % spA % xi , self % f % T_forward)

                  allocate ( self % f % T_backward ( 0:el1 % spA % N , 0:self % f % spA % N )  ) 
                  call TripleMatrixProduct( A = el1 % spA % Minv , B = self % f % T_forward , C = self % f % spA % M , val = self % f % T_backward , trB = .true. )
               end if
!
!              Search for the edge in element2: This is forced to be the RIGHT element, and can be either FORWARD, or BACKWARD
!              ---------------------------------------------------------------------------------------------------------------
               call searchEdge( nodesEl = nodesEl2 , nodesEdge = nodesID , needsInversion = needsInversion , edgePosition = edgePosition  , edgeDirection = edgeDirection)
!
!              Link the items
!              --------------
               el2  % edges     ( edgePosition ) % f => self % f
               self % f % quads ( RIGHT        ) % e => el2

               el2  % quadPosition     ( edgePosition )  = RIGHT
               el2  % edgesDirection   ( edgePosition )  = edgeDirection
               self % f % edgeLocation ( RIGHT        )  = edgePosition
               
               if ( edgeDirection .eq. FORWARD ) then
                  self % f % inverse = .false.

               else
                  self % f % inverse = .true.

               end if
               
               call self % f % storage (RIGHT) % Initialize ( el2 % spA )
!
!              State whether a transformation is needed or not.
!              -----------------------------------------------
               if ( el2 % spA % N .eq. self % f % spA % N ) then
                  self % f % transform (RIGHT) = .false.
            
               else
                  self % f % transform (RIGHT) = .true.
                  self % f % Nlow  = el2 % spA % N
!
!                 Computing the forward matrix: From the element degree to the edge
!                 -----------------------------------------------------------------
                  allocate ( self % f % T_forward   ( 0:self % f % spA % N , 0:el2 % spA % N )  ) 
                  call PolynomialInterpolationMatrix( el2 % spA % N , self % f % spA % N , el2 % spA % xi , el2 % spA % wb , self % f % spA % xi , self % f % T_forward)

                  allocate ( self % f % T_backward ( 0:el2 % spA % N , 0:self % f % spA % N )  ) 
                  call TripleMatrixProduct( A = el2 % spA % Minv , B = self % f % T_forward , C = self % f % spA % M , val = self % f % T_backward , trB = .true. )

               end if
!
!              Point to the correct procedure
!              ------------------------------
               if ( (.not. self % f % transform(LEFT)) .and. (.not. self % f % transform(RIGHT)) .and. (.not. self % f % inverse) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType1
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType1
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType1

               elseif ( (.not. self % f % transform(LEFT)) .and. (.not. self % f % transform(RIGHT)) .and. (self % f % inverse) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType2
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType2
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType2
   
               elseif ( ( self % f % transform(LEFT) ) .and. ( .not. self % f % inverse ) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType3
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType3
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType3

               elseif ( ( self % f % transform(LEFT) ) .and. ( self % f % inverse ) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType4
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType4
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType4
      
               elseif ( ( self % f % transform(RIGHT) ) .and. ( .not. self % f % inverse ) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType5
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType5
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType5

               elseif ( ( self % f % transform(RIGHT) ) .and. ( self % f % inverse ) ) then
                  self % f % ProjectSolution       => Edge_ProjectSolutionType6
                  self % f % ProjectFluxes         => Edge_ProjectFluxesType6
                  self % f % ProjectGradientFluxes => Edge_ProjectGradientFluxesType6

               end if
               

            elseif (present(elb) .and. (.not. present(el1)) .and. (.not. present(el2))) then ! Boundary edge

               allocate ( self % f % storage ( 1 ) ) 

               do node = 1 , POINTS_PER_QUAD 
                  nodesElb(node)  = elb % nodes(node) % n % ID 
               end do

!              Search for the edge in element1
!              -------------------------------
               call searchEdge( nodesEl = nodesElb , nodesEdge = nodesID , needsInversion = needsInversion , edgePosition = edgePosition , edgeDirection = edgeDirection)
!
!              Link the items: Now always the direction is FORWARD. This may be later reverted ONLY in the case Periodic BCs are enforced
!              --------------------------------------------------------------------------------------------------------------------------
               elb  % boundaryElement = .true.
               elb  % edges            ( edgePosition ) % f  => self % f
               self % f % quads        ( 1            ) % e  => elb

               elb % edgesDirection    ( edgePosition ) =  FORWARD
               elb % quadPosition      ( edgePosition ) = 1
               self % f % edgeLocation ( 1            ) =  edgePosition
!
!              Adapt the edge to the  element
!              ------------------------------
               if ( needsInversion ) then
                  if ( (edgePosition .eq. EBOTTOM) .or. (edgePosition .eq. ERIGHT) ) then
                     call self % f % Invert ( changeSigndS = .true. )
         
                  else
                     call self % f % Invert ( changeSigndS = .false. )

                  end if

               else     ! Change the sign of dS if is TOP or LEFT
                  if ( ( edgePosition .eq. ETOP) .or. (edgePosition .eq. ELEFT) ) then
                     self % f % n = -self % f % n

                  end if

               end if

               call self % f % storage (1) % Initialize ( elb % spA )
!
!              Boundary edges never need a transformation
!              ------------------------------------------
               self % f % transform = .false.

            end if

         end subroutine Edge_LinkWithElements

         subroutine Edge_Invert ( self , changeSigndS)
            implicit none
            class(Edge_t)           :: self
            logical, optional       :: changeSigndS
!           --------------------------------------
            logical                 :: changeSigndS_val
            class(Node_t), pointer  :: auxnode

            if ( present(changeSigndS) ) then
               changeSigndS_val = changeSigndS

            else
               changeSigndS_val = .true.

            end if

!           Invert nodes
            auxnode => self % nodes(1) % n
            self % nodes(1) % n => self % nodes(2) % n
            self % nodes(2) % n => auxnode

!           Invert coordinates
            self % X  ( 1:NDIM , 0:self % spA % N ) = self % X  ( 1:NDIM , self % spA % N : 0 : -1 ) 

            select type ( self )

               type is (Edge_t)
                  self % dX ( 1:NDIM , 0 ) = -self % dX ( 1:NDIM , 0 ) 
      
                  if ( changeSigndS_val ) then
                     self % n ( 1:NDIM , 0 ) = -self % n ( 1:NDIM , 0) 
      
                  end if

               type is (CurvedEdge_t)
                  self % dX ( 1:NDIM , 0:self % spA % N ) = -self % dX ( 1:NDIM , self % spA % N : 0 : -1 ) 
                  self % dS (          0:self % spA % N ) =  self % dS (          self % spA % N : 0 : -1 ) 
      
                  if ( changeSigndS_val ) then
                     self % n ( 1:NDIM , 0:self % spA % N ) = -self % n ( 1:NDIM , self % spA % N : 0 : -1 ) 
      
                  else
                     self % n ( 1:NDIM , 0:self % spA % N ) = self % n ( 1:NDIM , self % spA % N : 0 : -1 ) 
         
                  end if
 
         
               type is (StraightBdryEdge_t)
                  self % dX ( 1:NDIM , 0 ) = -self % dX ( 1:NDIM , 0 ) 
      
                  if ( changeSigndS_val ) then
                     self % n ( 1:NDIM , 0 ) = -self % n ( 1:NDIM , 0) 
      
                  end if
 
               type is (CurvedBdryEdge_t)
                  self % dX ( 1:NDIM , 0:self % spA % N ) = -self % dX ( 1:NDIM , self % spA % N : 0 : -1 ) 
                  self % dS (          0:self % spA % N ) =  self % dS (          self % spA % N : 0 : -1 ) 
      
                  if ( changeSigndS_val ) then
                     self % n ( 1:NDIM , 0:self % spA % N ) = -self % n ( 1:NDIM , self % spA % N : 0 : -1 ) 
      
                  else
                     self % n ( 1:NDIM , 0:self % spA % N ) = self % n ( 1:NDIM , self % spA % N : 0 : -1 ) 
         
                  end if
         
            end select
 
         end subroutine Edge_Invert
!
!//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
!
!              PROJECTION PROCEDURES
!              ---------------------
!//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
!
         pure subroutine Edge_ProjectSolutionType1( ed , QL , QR , dQL , dQR) 
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 

            QL = ed % storage(LEFT) % Q
            QR = ed % storage(RIGHT) % Q

#ifdef NAVIER_STOKES
            dQL = ed % storage(LEFT) % dQ
            dQR = ed % storage(RIGHT) % dQ
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif

         end subroutine Edge_ProjectSolutionType1

         pure subroutine Edge_ProjectSolutionType2( ed , QL , QR , dQL , dQR )
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 
            
            QL = ed % storage(LEFT) % Q
            QR = ed % storage(RIGHT) % Q( ed % spA % N : 0 : -1 , 1 : NCONS )

#ifdef NAVIER_STOKES
            dQL = ed % storage(LEFT) % dQ
            dQR = ed % storage(RIGHT) % dQ ( ed % spA % N : 0 : -1 , 1 : NDIM , 1 : NCONS )
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif

         end subroutine Edge_ProjectSolutionType2

         pure subroutine Edge_ProjectSolutionType3( ed , QL , QR , dQL , dQR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 
!
!           ---------------
!           Local variables
!           ---------------
!
            integer     :: eq

            call Mat_x_Mat( ed % T_forward , ed % storage(LEFT) % Q , QL)
            QR = ed % storage(RIGHT) % Q

#ifdef NAVIER_STOKES
            do eq = 1 , NCONS
               call Mat_x_Mat( ed % T_forward , ed % storage(LEFT) % dQ(:,:,eq) , dQL(:,:,eq) )
            end do
            dQR = ed % storage(RIGHT) % dQ
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif
            
         end subroutine Edge_ProjectSolutionType3

         pure subroutine Edge_ProjectSolutionType4( ed , QL , QR , dQL , dQR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 
!
!           ---------------
!           Local variables
!           ---------------
!
            integer     :: eq

            call Mat_x_Mat( ed % T_forward , ed % storage(LEFT) % Q , QL)
            QR = ed % storage(RIGHT) % Q( ed % spA % N : 0 : -1 , 1 : NCONS )

#ifdef NAVIER_STOKES
            do eq = 1 , NCONS
               call Mat_x_Mat( ed % T_forward , ed % storage(LEFT) % dQ(:,:,eq) , dQL(:,:,eq) )
            end do
            dQR = ed % storage(RIGHT) % dQ( ed % spA % N : 0 : -1 , 1 : NDIM , 1 : NCONS )
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif
            
         end subroutine Edge_ProjectSolutionType4

         pure subroutine Edge_ProjectSolutionType5( ed , QL , QR , dQL , dQR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 
!
!           ---------------
!           Local variables
!           ---------------
!
            integer     :: eq
 
            QL = ed % storage(LEFT) % Q
            call Mat_x_Mat( ed % T_forward , ed % storage(RIGHT) % Q , QR)

#ifdef NAVIER_STOKES
            dQL = ed % storage(LEFT) % dQ
            do eq = 1 , NCONS
               call Mat_x_Mat( ed % T_forward , ed % storage(RIGHT) % dQ(:,:,eq) , dQR(:,:,eq) )
            end do
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif
           
         end subroutine Edge_ProjectSolutionType5

         pure subroutine Edge_ProjectSolutionType6( ed , QL , QR , dQL , dQR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(out)    :: QL( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: QR( 0 : ed % spA % N , 1 : NCONS ) 
            real(kind=RP), intent(out)    :: dQL( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS )
            real(kind=RP), intent(out)    :: dQR( 0 : ed % spA % N , 1 : NDIM , 1 : NCONS ) 
!
!           ---------------
!           Local variables
!           ---------------
!
            integer     :: eq
  
            QL = ed % storage(LEFT) % Q
            call Mat_x_Mat( ed % T_forward , ed % storage(RIGHT) % Q , QR)
            QR = QR( ed % spA % N : 0 : -1 , 1 : NCONS ) 

#ifdef NAVIER_STOKES
            dQL = ed % storage(LEFT) % dQ
            do eq = 1 , NCONS
               call Mat_x_Mat( ed % T_forward , ed % storage(RIGHT) % dQ(:,:,eq) , dQR(:,:,eq) )
            end do
            dQR = ed % storage(RIGHT) % dQ( ed % spA % N : 0 : -1 , 1 : NDIM , 1 : NCONS )
#else
            dQL = 0.0_RP
            dQR = 0.0_RP
#endif
            
         end subroutine Edge_ProjectSolutionType6

         pure subroutine Edge_ProjectFluxesType1( ed , F , FL , FR) 
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )

            FL = F
            FR = -F

         end subroutine Edge_ProjectFluxesType1

         pure subroutine Edge_ProjectFluxesType2( ed , F , FL , FR )
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )
            
            FL = F
            FR = -F( ed % spA % N : 0 : -1 , 1 : NCONS )

         end subroutine Edge_ProjectFluxesType2

         pure subroutine Edge_ProjectFluxesType3( ed , F , FL , FR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )

            call Mat_x_Mat( ed % T_backward , F , FL)
            FR = -F
            
         end subroutine Edge_ProjectFluxesType3

         pure subroutine Edge_ProjectFluxesType4( ed , F , FL , FR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )

            call Mat_x_Mat( ed % T_backward , F , FL )
            FR = -F( ed % spA % N : 0 : -1 , 1 : NCONS )

         end subroutine Edge_ProjectFluxesType4

         pure subroutine Edge_ProjectFluxesType5( ed , F , FL , FR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )

            FL = F
            call Mat_x_Mat( ed % T_backward , -F , FR )
           
         end subroutine Edge_ProjectFluxesType5

         pure subroutine Edge_ProjectFluxesType6( ed , F , FL , FR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: F ( 0 : ed % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS )
            real(kind=RP), intent(out)    :: FR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS )
            
            FL = F
            call Mat_x_Mat( ed % T_backward , F , FR )
            FR = -FR( ed % Nlow : 0 : -1 , 1 : NCONS )

         end subroutine Edge_ProjectFluxesType6

         pure subroutine Edge_ProjectGradientFluxesType1( ed , GL_edge , GR_edge , GL , GR) 
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )

            GL = GL_edge
            GR = GR_edge

         end subroutine Edge_ProjectGradientFluxesType1

         pure subroutine Edge_ProjectGradientFluxesType2( ed , GL_edge , GR_edge , GL , GR)
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )
            
            GL = GL_edge
            GR = GR_edge( ed % spA % N : 0 : -1 , 1 : NCONS , 1 : NDIM )

         end subroutine Edge_ProjectGradientFluxesType2

         pure subroutine Edge_ProjectGradientFluxesType3( ed , GL_edge , GR_edge , GL , GR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )
               
            call Mat_x_Mat( ed % T_backward , GL_edge(:,:,IX) , GL(:,:,IX) )
            call Mat_x_Mat( ed % T_backward , GL_edge(:,:,IY) , GL(:,:,IY) )
            GR = GR_edge
            
         end subroutine Edge_ProjectGradientFluxesType3

         pure subroutine Edge_ProjectGradientFluxesType4( ed , GL_edge , GR_edge , GL , GR)
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )
               
            call Mat_x_Mat( ed % T_backward , GL_edge(:,:,IX) , GL(:,:,IX) )
            call Mat_x_Mat( ed % T_backward , GL_edge(:,:,IY) , GL(:,:,IY) )
            GR = GR_edge( ed % spA % N : 0 : -1 , 1 : NCONS , 1 : NDIM)

         end subroutine Edge_ProjectGradientFluxesType4

         pure subroutine Edge_ProjectGradientFluxesType5( ed , GL_edge , GR_edge , GL , GR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )

            GL = GL_edge
            call Mat_x_Mat( ed % T_backward , GR_edge(:,:,IX) , GR(:,:,IX) )
            call Mat_x_Mat( ed % T_backward , GR_edge(:,:,IY) , GR(:,:,IY) )
           
         end subroutine Edge_ProjectGradientFluxesType5

         pure subroutine Edge_ProjectGradientFluxesType6( ed , GL_edge , GR_edge , GL , GR )
            use MatrixOperations
            implicit none
            class(Edge_t), intent(in)     :: ed
            real(kind=RP), intent(in)     :: GL_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(in)     :: GR_edge ( 0 : ed % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GL( 0 : ed % storage(LEFT) % spA % N , 1 : NCONS , 1 : NDIM )
            real(kind=RP), intent(out)    :: GR( 0 : ed % storage(RIGHT) % spA % N , 1 : NCONS , 1 : NDIM )

            GL = GL_edge
            call Mat_x_Mat( ed % T_backward , GR_edge(:,:,IX) , GR(:,:,IX) )
            call Mat_x_Mat( ed % T_backward , GR_edge(:,:,IY) , GR(:,:,IY) )

            GR = GR( ed % Nlow : 0 : -1 , 1 : NCONS , 1 : NDIM )

         end subroutine Edge_ProjectGradientFluxesType6

         pure function Edge_ComputeJumps ( ed , var ) result ( jumps )
            use MatrixOperations
            implicit none
            class(Edge_t),    intent(in)     :: ed
            integer      ,    intent(in)     :: var
            real(kind=RP)                    :: jumps
!
!           ---------------
!           Local variables
!           ---------------
!
            real(kind=RP)     :: QL( 0 : ed % spA % N )
            real(kind=RP)     :: QR( 0 : ed % spA % N )
            real(kind=RP)     :: nodalJumps ( 0 : ed % spA % N )
   
            if ( ed % transform(LEFT) .and. ed % inverse ) then
!    
!           ---------------------------------------------------------
!>          First case: LEFT needs p-Adaption, and RIGHT is reversed.
!           ---------------------------------------------------------
!   
!              Transform the LEFT edge
!              -----------------------            
               QL = MatrixTimesVector_F( ed % T_forward , ed % storage(LEFT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Invert the RIGHT edge
!              ---------------------
               QR = ed % storage(RIGHT) % Q(ed % spA % N : 0 : -1 , var )
   
            elseif ( ed % transform(LEFT) ) then
!    
!           ----------------------------------
!>          Second case: LEFT needs p-Adaption.
!           ----------------------------------
!   
!              Transform the LEFT 
!              -----------------------
               QL = MatrixTimesVector_F( ed % T_forward , ed % storage(LEFT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Get the RIGHT edge state
!              ------------------------
               QR = ed % storage(RIGHT) % Q(:,var)
   
            elseif ( ed % transform(RIGHT) .and.  ed % inverse ) then
!    
!           ---------------------------------------------------------
!>          Third case: RIGHT needs p-Adaption, and RIGHT is reversed.
!           ---------------------------------------------------------
!   
!              Get the LEFT edge 
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Transform the RIGHT edge 
!              ------------------------
               QR = MatrixTimesVector_F( ed % T_forward , ed % storage(RIGHT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Invert the RIGHT edge 
!              ---------------------
               QR(0:ed % spA % N) = QR(ed % spA % N : 0 : -1)
   
            elseif ( ed % transform(RIGHT) ) then
!    
!           -----------------------------------
!>          Fourth case: RIGHT needs p-Adaption.
!           -----------------------------------
!   
!              Get the LEFT edge
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Transform the RIGHT edge
!              ------------------------
               QR = MatrixTimesVector_F( ed % T_forward , ed % storage(RIGHT) % Q(:,var) , ed % spA % N + 1 )
            
            elseif ( ed % inverse ) then
!    
!           -----------------------------
!>          Fifth case: RIGHT is reversed.
!           -----------------------------
!   
!              Get the LEFT edge
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Invert the RIGHT edge
!              ---------------------
               QR = ed % storage(RIGHT) % Q(ed % spA % N : 0 : -1 , var)
   
            else
!    
!           -----------------------------------------------------------------------
!>          Sixth case: Default case: neither p-Adaption nor inversion are required.
!           -----------------------------------------------------------------------
!   
!              Get the LEFT edge 
!              -----------------   
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Get the RIGHT edge
!              ------------------
               QR = ed % storage(RIGHT) % Q(:,var)
            
            end if
   
!   
!           Compute the Jumps
!           -----------------
            nodalJumps = 2.0_RP * ( QL - QR ) / ( QL + QR )
            jumps = sum( ed % spA % w * nodalJumps * nodalJumps * ed % dS(0))
   
         end function Edge_ComputeJumps

         pure function CurvedEdge_ComputeJumps ( ed , var ) result ( jumps )
            use MatrixOperations
            implicit none
            class(CurvedEdge_t),    intent(in)     :: ed
            integer      ,    intent(in)     :: var
            real(kind=RP)                    :: jumps
!
!           ---------------
!           Local variables
!           ---------------
!
            real(kind=RP)     :: QL( 0 : ed % spA % N )
            real(kind=RP)     :: QR( 0 : ed % spA % N )
            real(kind=RP)     :: nodalJumps ( 0 : ed % spA % N )
   
            if ( ed % transform(LEFT) .and. ed % inverse ) then
!    
!           ---------------------------------------------------------
!>          First case: LEFT needs p-Adaption, and RIGHT is reversed.
!           ---------------------------------------------------------
!   
!              Transform the LEFT edge
!              -----------------------            
               QL = MatrixTimesVector_F( ed % T_forward , ed % storage(LEFT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Invert the RIGHT edge
!              ---------------------
               QR = ed % storage(RIGHT) % Q(ed % spA % N : 0 : -1 , var )
   
            elseif ( ed % transform(LEFT) ) then
!    
!           ----------------------------------
!>          Second case: LEFT needs p-Adaption.
!           ----------------------------------
!   
!              Transform the LEFT 
!              -----------------------
               QL = MatrixTimesVector_F( ed % T_forward , ed % storage(LEFT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Get the RIGHT edge state
!              ------------------------
               QR = ed % storage(RIGHT) % Q(:,var)
   
            elseif ( ed % transform(RIGHT) .and.  ed % inverse ) then
!    
!           ---------------------------------------------------------
!>          Third case: RIGHT needs p-Adaption, and RIGHT is reversed.
!           ---------------------------------------------------------
!   
!              Get the LEFT edge 
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Transform the RIGHT edge 
!              ------------------------
               QR = MatrixTimesVector_F( ed % T_forward , ed % storage(RIGHT) % Q(:,var) , ed % spA % N + 1 )
!   
!              Invert the RIGHT edge 
!              ---------------------
               QR(0:ed % spA % N) = QR(ed % spA % N : 0 : -1)
   
            elseif ( ed % transform(RIGHT) ) then
!    
!           -----------------------------------
!>          Fourth case: RIGHT needs p-Adaption.
!           -----------------------------------
!   
!              Get the LEFT edge
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Transform the RIGHT edge
!              ------------------------
               QR = MatrixTimesVector_F( ed % T_forward , ed % storage(RIGHT) % Q(:,var) , ed % spA % N + 1 )
            
            elseif ( ed % inverse ) then
!    
!           -----------------------------
!>          Fifth case: RIGHT is reversed.
!           -----------------------------
!   
!              Get the LEFT edge
!              -----------------
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Invert the RIGHT edge
!              ---------------------
               QR = ed % storage(RIGHT) % Q(ed % spA % N : 0 : -1 , var)
   
            else
!    
!           -----------------------------------------------------------------------
!>          Sixth case: Default case: neither p-Adaption nor inversion are required.
!           -----------------------------------------------------------------------
!   
!              Get the LEFT edge 
!              -----------------   
               QL = ed % storage(LEFT) % Q(:,var)
!   
!              Get the RIGHT edge
!              ------------------
               QR = ed % storage(RIGHT) % Q(:,var)
            
            end if
   
!   
!           Compute the Jumps
!           -----------------
            nodalJumps = 2.0_RP * ( QL - QR ) / ( QL + QR )
            jumps = sum( ed % spA % w * nodalJumps * nodalJumps * ed % dS)
   
         end function CurvedEdge_ComputeJumps

         pure function StraightBdryEdge_ComputeJumps ( ed , var ) result ( jumps )
            use MatrixOperations
            implicit none
            class(StraightBdryEdge_t),    intent(in) :: ed
            integer      ,    intent(in)             :: var
            real(kind=RP)                            :: jumps
!
!           ---------------
!           Local variables
!           ---------------
!
            real(kind=RP)     :: QL( 0 : ed % spA % N )
            real(kind=RP)     :: QR( 0 : ed % spA % N )
            real(kind=RP)     :: nodalJumps ( 0 : ed % spA % N ) 

         if ( ed % inverse ) then
! 
!        -----------------------------
!>       First case: RIGHT is reversed.
!        -----------------------------
!
!           Get the LEFT edge
!           -----------------
            QL = ed % storage(1) % Q(:,var)
!
!           Invert the RIGHT edge
!           ---------------------
#ifdef NAVIER_STOKES
            QR(0:ed % spA % N) = ed % uSB(ed % spA % N : 0 : -1 , var )
#else
            QR(0:ed % spA % N) = ed % uB(ed % spA % N : 0 : -1 , var )
#endif

         else
! 
!        -----------------------------------------------------------------------
!>       Second case: Default case: neither p-Adaption nor inversion are required.
!        -----------------------------------------------------------------------
!
!           Get the LEFT edge 
!           -----------------   
            QL = ed % storage(1) % Q(:,var)
!
!           Get the RIGHT edge
!           ------------------
#ifdef NAVIER_STOKES
            QR = ed % uSB(:,var)
#else
            QR = ed % uB(:,var)
#endif
      
         
         end if
!
!        Compute the Jumps
!        -----------------
         nodalJumps = 2.0_RP * ( QL - QR ) / ( QL + QR )
         jumps = sum( ed % spA % w * nodalJumps * nodalJumps * ed % dS(0))

         end function StraightBdryEdge_ComputeJumps

         pure function CurvedBdryEdge_ComputeJumps ( ed , var ) result ( jumps )
            use MatrixOperations
            implicit none
            class(CurvedBdryEdge_t),    intent(in) :: ed
            integer      ,    intent(in)           :: var
            real(kind=RP)                          :: jumps
!
!           ---------------
!           Local variables
!           ---------------
!
            real(kind=RP)     :: QL( 0 : ed % spA % N )
            real(kind=RP)     :: QR( 0 : ed % spA % N )
            real(kind=RP)     :: nodalJumps( 0 : ed % spA % N ) 

         if ( ed % inverse ) then
! 
!        -----------------------------
!>       First case: RIGHT is reversed.
!        -----------------------------
!
!           Get the LEFT edge
!           -----------------
            QL = ed % storage(1) % Q(:,var)
!
!           Invert the RIGHT edge
!           ---------------------
#ifdef NAVIER_STOKES
            QR(0:ed % spA % N) = ed % uSB(ed % spA % N : 0 : -1 , var )
#else
            QR(0:ed % spA % N) = ed % uB(ed % spA % N : 0 : -1 , var )
#endif

         else
! 
!        -----------------------------------------------------------------------
!>       Second case: Default case: neither p-Adaption nor inversion are required.
!        -----------------------------------------------------------------------
!
!           Get the LEFT edge 
!           -----------------   
            QL = ed % storage(1) % Q(:,var)
!
!           Get the RIGHT edge
!           ------------------
#ifdef NAVIER_STOKES
            QR = ed % uSB(:,var)
#else
            QR = ed % uB(:,var)
#endif
         
         end if
!
!        Compute the Jumps
!        -----------------
         nodalJumps = 2.0_RP * ( QL - QR ) / ( QL + QR )
         jumps = sum( ed % spA % w * nodalJumps * nodalJumps * ed % dS(0))

         end function CurvedBdryEdge_ComputeJumps

         subroutine BoundaryData_Initialize( self , spA  ) 
            implicit none
            class(BoundaryData_t)             :: self
            class(NodesAndWeights_t), pointer :: spA

            self % spA => spA

            allocate ( self % Q  ( 0 : self % spA % N , NCONS )  ) 
#ifdef NAVIER_STOKES
            allocate ( self % dQ ( 0 : self % spA % N , NDIM  , NCONS ) ) 
#endif

         end subroutine BoundaryData_Initialize
