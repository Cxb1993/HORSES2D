   subroutine QuadElement_SetMappings ( self ) 
      use MatrixOperations
      implicit none
      class(QuadElement_t)          :: self 
      integer                       :: ixi , ieta
!
!     **************************************
!     Set the mapping for the inner points X
!        Also, compute dX, the derivatives
!     **************************************
!
      associate ( N => self % spA % N , xi => self % spA % xi , eta => self % spA % xi , &
                  gBOT => self % edges(EBOTTOM) % f , & 
                  gTOP => self % edges(ETOP) % f  , & 
                  gLEFT => self % edges(ELEFT) % f , & 
                  gRIGHT => self % edges(ERIGHT) % f , & 
                  dBOT => self % edgesDirection(EBOTTOM) , &
                  dTOP => self % edgesDirection(ETOP) , & 
                  dLEFT => self % edgesDirection(ELEFT) , & 
                  dRIGHT => self % edgesDirection(ERIGHT) , & 
                  n1 => self % nodes(1) % n % X , n2 => self % nodes(2) % n % X , n3 => self % nodes(3) % n % X , n4 => self % nodes(4) % n % X ) 

         do ixi = 0 , N
            do ieta = 0 , N 
               
               self % X(iXi , iEta, IX:IY) =  (1.0_RP - eta(iEta)) * gBOT % getX(iXi,dBOT) + xi(iXi)*gRIGHT % getX(iEta,dRIGHT) + &
                                              (1.0_RP - xi(iXi) )  * gLEFT % getX(iEta,-dLEFT) + eta(iEta)*gTOP % getX(iXi,-dTOP)  &
                                              -n1*(1.0_RP - xi(iXi))*(1.0_RP - eta(iEta)) - n2 * xi(iXi) * (1.0_RP - eta(iEta)) & 
                                              -n3* xi(iXi) * eta(iEta) - n4 * (1.0_RP - xi(iXi)) * eta(iEta)

               self % dX(iXi,iEta,IX:IY,IX) = (1.0_RP - eta(iEta)) * gBOT % getdX(iXi,dBOT) + gRIGHT % getX(iEta,dRIGHT) + &
                                                   eta(iEta) * gTOP % getdX(iXi,-dTOP) + (-1.0_RP) * gLEFT % getX(iEta,-dLEFT) + &
                                              -n1 *(1.0_RP - eta(iEta))*(-1.0_RP) - n2 * (1.0_RP - eta(iEta)) & 
                                              -n3 * eta(iEta) - n4 * (-1.0_RP) * eta(iEta)

               self % dX(iXi,iEta,IX:IY,IY) =  (-1.0_RP) * gBOT % getX(iXi,dBOT) + xi(iXi)*gRIGHT % getdX(iEta,dRIGHT) + &
                                              (1.0_RP - xi(iXi) )  * gLEFT % getdX(iEta,-dLEFT) + gTOP % getX(iXi,-dTOP)  &
                                              -n1*(1.0_RP - xi(iXi))*(-1.0_RP) - n2 * xi(iXi) * (-1.0_RP) & 
                                              -n3* xi(iXi) - n4 * (1.0_RP - xi(iXi))

               self % jac(iXi,iEta)         = self % dX(iXi,iEta,IX,IX) * self % dX(iXi,iEta,IY,IY) - self % dX(iXi,iEta,IX,IY) * self % dX(iXi,iEta,IY,IX)

               self % invM2Djac(iXi,iEta)   = self % spA % invM2D(iXi,iEta) / self % jac(iXi,iEta)

            end do
         end do

      end associate


   end subroutine QuadElement_SetMappings

   function QuadElement_MetricMatrix ( self , which , iXi , iEta ) result (val)
      implicit none
      class(QuadElement_t),intent(in)           :: self
      integer,             intent(in)           :: which(NDIM)
      integer,             intent(in), optional :: iXi(:)
      integer,             intent(in), optional :: iEta(:)
      real(kind=RP), allocatable                :: val(:,:)
      real(kind=RP)                             :: newsign

      if (present(iXi) .and. present(iEta)) then

         allocate ( val(size(iXi,1) , size(iEta,1) ) )

         if ((which(1) .eq. 1) .and. (which(2) .eq. 1)) then      ! Ja(1,1) = Y_eta
            val = self % dX(iXi,iEta,IY,IY)
         elseif ((which(1) .eq. 1) .and. (which(2) .eq. 2)) then  ! Ja(1,2) = -Y_xi            
            val = -self % dX(iXi,iEta,IY,IX)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 1)) then  ! Ja(2,1) = -X_eta
            val = -self % dX(iXi,iEta,IX,IY)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 2)) then  ! Ja(2,2) = X_xi
            val = self % dX(iXi,iEta,IX,IX)
         end if

      else

         allocate( val(size(self % dX,2),size(self % dX,3) ) )

         if ((which(1) .eq. 1) .and. (which(2) .eq. 1)) then      ! Ja(1,1) = Y_eta
            val = self % dX(:,:,IY,IY)
         elseif ((which(1) .eq. 1) .and. (which(2) .eq. 2)) then  ! Ja(1,2) = -Y_xi            
            val = -self % dX(:,:,IY,IX)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 1)) then  ! Ja(2,1) = -X_eta
            val = -self % dX(:,:,IX,IY)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 2)) then  ! Ja(2,2) = X_xi
            val = self % dX(:,:,IX,IX)
         end if


      end if

      
   end function QuadElement_MetricMatrix

   function QuadElement_Compute_X ( self , xi , eta ) result (val)
      use MatrixOperations
      implicit none
      class(QuadElement_t), intent(in)       :: self
      real(kind=RP)       , intent(in)       :: xi
      real(kind=RP)       , intent(in)       :: eta
      real(kind=RP)                          :: val(NDIM)
!     ---------------------------------------------------------
      real(kind=RP), allocatable             :: l_xi(:) , l_eta(:)

      associate ( N => self % spA % N )

      allocate( l_xi ( 0 : N ) , l_eta ( 0 : N ) )

      l_xi = self % spA % lj(xi)
      l_eta = self % spA % lj(eta)

      call BilinearForm( self % X(0:N,0:N,IX) , l_xi , l_eta , val(IX) )
      call BilinearForm( self % X(0:N,0:N,IY) , l_xi , l_eta , val(IY) )

      deallocate( l_xi , l_eta )

      end associate

   end function QuadElement_Compute_X
   
