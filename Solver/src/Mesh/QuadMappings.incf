   subroutine QuadElement_SetMappings ( self ) 
      use MatrixOperations
      implicit none
      class(QuadElement_t)          :: self 
      integer                       :: ixi , ieta
!
!     **************************************
!     Set the mapping for the inner points X
!        Also, compute dX, the derivatives
!     **************************************
!
      associate ( N => self % spA % N , xi => self % spA % xi , eta => self % spA % xi , &
                  gBOT => self % edges(EBOTTOM) % f , & 
                  gTOP => self % edges(ETOP) % f  , & 
                  gLEFT => self % edges(ELEFT) % f , & 
                  gRIGHT => self % edges(ERIGHT) % f , & 
                  dBOT => self % edgesDirection(EBOTTOM) , &
                  dTOP => self % edgesDirection(ETOP) , & 
                  dLEFT => self % edgesDirection(ELEFT) , & 
                  dRIGHT => self % edgesDirection(ERIGHT) , & 
                  n1 => self % nodes(1) % n % X , n2 => self % nodes(2) % n % X , n3 => self % nodes(3) % n % X , n4 => self % nodes(4) % n % X ) 

         do ixi = 0 , N
            do ieta = 0 , N 
               
               self % x(iX:iY, ixi , ieta) =  (1.0_RP - eta(iEta)) * gBOT % getX(iXi,dBOT) + xi(iXi)*gRIGHT % getX(iEta,dRIGHT) + &
                                              (1.0_RP - xi(iXi) )  * gLEFT % getX(iEta,-dLEFT) + eta(iEta)*gTOP % getX(iXi,-dTOP)  &
                                              -n1*(1.0_RP - xi(iXi))*(1.0_RP - eta(iEta)) - n2 * xi(iXi) * (1.0_RP - eta(iEta)) & 
                                              -n3* xi(iXi) * eta(iEta) - n4 * (1.0_RP - xi(iXi)) * eta(iEta)

               self % dx(iX:iY,ixi,ieta,iX) = (1.0_RP - eta(iEta)) * gBOT % getdX(iXi,dBOT) + gRIGHT % getX(iEta,dRIGHT) + &
                                                   eta(iEta) * gTOP % getdX(iXi,-dTOP) + (-1.0_RP) * gLEFT % getX(iEta,-dLEFT) + &
                                              -n1 *(1.0_RP - eta(iEta))*(-1.0_RP) - n2 * (1.0_RP - eta(iEta)) & 
                                              -n3 * eta(iEta) - n4 * (-1.0_RP) * eta(iEta)

               self % dx(iX:iY,iXi,iEta,iY) =  (-1.0_RP) * gBOT % getX(iXi,dBOT) + xi(iXi)*gRIGHT % getdX(iEta,dRIGHT) + &
                                              (1.0_RP - xi(iXi) )  * gLEFT % getdX(iEta,-dLEFT) + gTOP % getX(iXi,-dTOP)  &
                                              -n1*(1.0_RP - xi(iXi))*(-1.0_RP) - n2 * xi(iXi) * (-1.0_RP) & 
                                              -n3* xi(iXi) - n4 * (1.0_RP - xi(iXi))

               self % jac(iXi,iEta)         = self % dX(iX,iXi,iEta,iX) * self % dX(iY,iXi,iEta,iY) - self % dX(iX,iXi,iEta,iY) * self % dX(iY,iXi,iEta,iX)

               self % invM2Djac(iXi,iEta)   = self % spA % invM2D(iXi,iEta) / self % jac(iXi,iEta)

            end do
         end do

      end associate


   end subroutine QuadElement_SetMappings

   function QuadElement_MetricMatrix ( self , which , iXi , iEta ) result (val)
      implicit none
      class(QuadElement_t),intent(in)           :: self
      integer,             intent(in)           :: which(NDIM)
      integer,             intent(in), optional :: iXi(:)
      integer,             intent(in), optional :: iEta(:)
      real(kind=RP), allocatable                :: val(:,:)
      real(kind=RP)                             :: newsign

      if (present(iXi) .and. present(iEta)) then

         allocate ( val(size(iXi,1) , size(iEta,1) ) )

         if ((which(1) .eq. 1) .and. (which(2) .eq. 1)) then      ! Ja(1,1) = Y_eta
            val = self % dX(iY,iXi,iEta,iY)
         elseif ((which(1) .eq. 1) .and. (which(2) .eq. 2)) then  ! Ja(1,2) = -Y_xi            
            val = -self % dX(iY,iXi,iEta,iX)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 1)) then  ! Ja(2,1) = -X_eta
            val = -self % dX(iX,iXi,iEta,iY)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 2)) then  ! Ja(2,2) = X_xi
            val = self % dX(iX,iXi,iEta,iX)
         end if

      else

         allocate( val(size(self % dX,2),size(self % dX,3) ) )

         if ((which(1) .eq. 1) .and. (which(2) .eq. 1)) then      ! Ja(1,1) = Y_eta
            val = self % dX(iY,:,:,iY)
         elseif ((which(1) .eq. 1) .and. (which(2) .eq. 2)) then  ! Ja(1,2) = -Y_xi            
            val = -self % dX(iY,:,:,iX)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 1)) then  ! Ja(2,1) = -X_eta
            val = -self % dX(iX,:,:,iY)
         elseif ((which(1) .eq. 2) .and. (which(2) .eq. 2)) then  ! Ja(2,2) = X_xi
            val = self % dX(iX,:,:,iX)
         end if


      end if

      
   end function QuadElement_MetricMatrix
   
