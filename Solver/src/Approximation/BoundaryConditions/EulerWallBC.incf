!
!///////////////////////////////////////////////////////////////////////////////////
!
!           EULER WALL
!           ----------
!///////////////////////////////////////////////////////////////////////////////////
!
      subroutine EulerWall_Associate( self , edge ) 
         implicit none  
         class(EulerWall_t)                  :: self
         class(Edge_t)                       :: edge

         associate( N => edge % spA % N )
         select type ( edge )
         
            type is (Edge_t)
               print*, "Only boundary edges are expected."
               stop "Stopped"

            type is (StraightBdryEdge_t)
               allocate( edge % FB(0:N,NCONS) )
               allocate( edge % uB(0:N,NCONS) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               edge % wB(0:,1:) => edge % storage(1) % W(0:,1:)
#ifdef NAVIER_STOKES
!
!              Gradients are computed from the interior
!              ----------------------------------------
               edge % gB(0:,1:,1:) => edge % storage(1) % dQ(0:,1:,1:)
#endif
         
            type is (CurvedBdryEdge_t)
               allocate( edge % FB(0:N,NCONS) )
               allocate( edge % uB(0:N,NCONS) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               edge % wB(0:,1:) => edge % storage(1) % W(0:,1:)
#ifdef NAVIER_STOKES
!
!              Gradients are computed from the interior
!              ----------------------------------------
               edge % gB(0:,1:,1:) => edge % storage(1) % dQ(0:,1:,1:)
#endif

            class default
         end select
         end associate
                
      end subroutine EulerWall_Associate


      subroutine EulerWall_UpdateSolution( self , edge )
         implicit none  
         class(EulerWall_t)                  :: self
         class(Edge_t)                       :: edge
         real(kind=RP)                       :: q(NCONS) , F(NCONS,NDIM)
         real(kind=RP)                       :: rhovn , rhovt
         real(kind=RP)                       :: p
         integer                             :: iXi
         
         associate( N => edge % spA % N , gm1 => Thermodynamics % gm1 , gamma => Thermodynamics % gamma , Mach => Dimensionless % Mach )
   
         select type ( edge ) 
            type is (StraightBdryEdge_t)

               do iXi = 0 , N
!
!                 The flux is computed by substracting the normal velocity to the interior state. Pressure and density are gathered from the interior
!                 -----------------------------------------------------------------------------------------------------------------------------------
                  rhovn = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IX,iXi) + edge % storage(1) % Q(iXi,IRHOV) * edge % n(IY,iXi) )
                  rhovt = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IY,iXi) - edge % storage(1) % Q(iXi,IRHOV) * edge % n(IX,iXi) )
                  p     = gm1 * (edge % storage(1) % Q(iXi,IRHOE) - 0.5_RP * (edge % storage(1) % Q(iXi,IRHOU)*edge % storage(1) % Q(iXi,IRHOU) + edge % storage(1) % Q(iXi,IRHOV) * edge % storage(1) % Q(iXi,IRHOV)) / edge % storage(1) % Q(iXi,IRHO))

                  q(IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  q(IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - rhovn * edge % n(IX,iXi)
                  q(IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - rhovn * edge % n(IY,iXi)
                  q(IRHOE) = Dimensionless % cv * p + 0.5_RP * rhovt * rhovt / edge % storage(1) % Q(iXi,IRHO)
!
!                 Compute the fluxex from the built state
!                 ---------------------------------------
                  F = inviscidFlux( q )
!
!                 Compute the normal flux
!                 -----------------------
                  edge % FB(iXi,1:NCONS) = F(1:NCONS,IX) * edge % dS(IX,iXi) + F(1:NCONS,IY) * edge % dS(IY,iXi)
!
!                 Compute the variables state
!                 ---------------------------
                  edge % uB(iXi,IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  edge % uB(iXi,IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - 2.0_RP * rhovn * edge % n(IX,iXi)
                  edge % uB(iXi,IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - 2.0_RP * rhovn * edge % n(IY,iXi)
                  edge % uB(iXi,IRHOE) = edge % storage(1) % Q(iXi,IRHOE)

               end do
                  
         
            type is (CurvedBdryEdge_t)

               do iXi = 0 , N
!
!                 The flux is computed by substracting the normal velocity to the interior state. Pressure and density are gathered from the interior
!                 -----------------------------------------------------------------------------------------------------------------------------------
                  rhovn = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IX,iXi) + edge % storage(1) % Q(iXi,IRHOV) * edge % n(IY,iXi) )
                  rhovt = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IY,iXi) - edge % storage(1) % Q(iXi,IRHOV) * edge % n(IX,iXi) )
                  p     = gm1 * (edge % storage(1) % Q(iXi,IRHOE) - 0.5_RP * (edge % storage(1) % Q(iXi,IRHOU)*edge % storage(1) % Q(iXi,IRHOU) + edge % storage(1) % Q(iXi,IRHOV) * edge % storage(1) % Q(iXi,IRHOV)) / edge % storage(1) % Q(iXi,IRHO))

                  q(IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  q(IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - rhovn * edge % n(IX,iXi)
                  q(IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - rhovn * edge % n(IY,iXi)
                  q(IRHOE) = Dimensionless % cv * p + 0.5_RP * rhovt * rhovt / edge % storage(1) % Q(iXi,IRHO)
!
!                 Compute the fluxex from the built state
!                 ---------------------------------------
                  F = inviscidFlux( q )
!
!                 Compute the normal flux
!                 -----------------------
                  edge % FB(iXi,1:NCONS) = F(1:NCONS,IX) * edge % dS(IX,iXi) + F(1:NCONS,IY) * edge % dS(IY,iXi)
!
!                 Compute the variables state
!                 ---------------------------
                  edge % uB(iXi,IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  edge % uB(iXi,IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - 2.0_RP * rhovn * edge % n(IX,iXi)
                  edge % uB(iXi,IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - 2.0_RP * rhovn * edge % n(IY,iXi)
                  edge % uB(iXi,IRHOE) = edge % storage(1) % Q(iXi,IRHOE)

               end do
 
            class default
         end select

         end associate

      end subroutine EulerWall_UpdateSolution

