!
!///////////////////////////////////////////////////////////////////////////////////
!
!           DIRICHLET BC
!           ------------
!///////////////////////////////////////////////////////////////////////////////////
!
      subroutine DirichletBC_Construct( self , marker , in_label)
         use Setup_class
         implicit none
         class(DirichletBC_t)      :: self
         integer                   :: marker
         character(len=*)          :: in_label
         real(kind=RP), allocatable             :: pressure
         real(kind=RP), allocatable         :: Temperature
         real(kind=RP), allocatable         :: Mach
         real(kind=RP), allocatable         :: AngleOfAttack
         real(kind=RP)                          :: rho

         call readValueInRegion( trim(Setup % bdry_file) , "pressure" , pressure , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Temperature", Temperature , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Mach" , Mach , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Angle of attack" , AngleOfAttack , in_label , "# end")
         
         if ( allocated(pressure) ) then
            pressure = pressure / refValues % p
         else
            allocate(pressure)
            pressure = 1.0_RP
         end if

         if ( allocated(Temperature) ) then
            Temperature = Temperature / refValues % T
         else
            allocate(Temperature)
            Temperature = 1.0_RP
         end if

         if ( .not. allocated(Mach) ) then
            allocate(Mach)
            Mach = Dimensionless % Mach
         end if

         if ( allocated(AngleOfAttack) ) then
            AngleOfAttack = AngleOfAttack * PI / 180.0_RP
         else
            allocate(AngleOfAttack)
            AngleOfAttack = 0.0_RP
         end if
!
!        Construct the state vector
!        --------------------------
         associate ( gamma => Thermodynamics % Gamma , cv => Dimensionless % cv)
         rho = pressure / Temperature
         self % q(IRHO) = rho
         self % q(IRHOU) = rho * sqrt(gamma) * Mach * cos(AngleOfAttack)
         self % q(IRHOV) = rho * sqrt(gamma) * Mach * sin(AngleOfAttack)
         self % q(IRHOE) = cv * pressure + 0.5_RP * rho * gamma * Mach * Mach
         end associate

      end subroutine DirichletBC_Construct

      subroutine DirichletBC_Associate(self , edge)
         implicit none
         class(DirichletBC_t)          :: self
         class(Edge_t)                 :: edge
         integer                       :: i

         associate ( N => edge % spA % N )

         select type ( edge )
         
            type is (Edge_t)
               print*, "Only boundary edges are expected."
               stop "Stopped"
      
            type is (StraightBdryEdge_t)
               allocate( edge % uB(0:N,NCONS) )
               allocate( edge % wB(0:N,NPRIM) ) 
               allocate( edge % gB(0:N,NDIM,NGRAD) ) 
               
               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               do i = 0 , N
                  edge % uB(i , 1:NCONS) = self % q
   
                  edge % wB(i , IRHO) = self % q(IRHO)
                  edge % wB(i , IU  ) = self % q(IRHOU) / self % q(IRHO)
                  edge % wB(i , IV  ) = self % q(IRHOV) / self % q(IRHO)
                  edge % wB(i , IP  ) = thermodynamics % gm1 * ( self % q(IRHOE) - 0.5_RP * ( edge % wB(i,IU) * edge % uB(i,IRHOU) + edge % wB(i,IV) * edge % uB(i,IRHOV) ) ) 
                  edge % wB(i , IT  ) = edge % wB(i , IP) / edge % wB(i , IRHO)
                  edge % wB(i , IA  ) = sqrt( thermodynamics % gamma * edge % wB(i,IT) )

#ifdef NAVIER_STOKES
                  edge % gB(i , 1:NDIM , 1:NGRAD) = 0.0_RP
#endif
               end do

            type is (CurvedBdryEdge_t)
               allocate( edge % uB(0:N,NCONS) )
               allocate( edge % wB(0:N,NPRIM) ) 
               allocate( edge % gB(0:N,NDIM,NGRAD) ) 
               
               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               do i = 0 , N
                  edge % uB(i , 1:NCONS) = self % q
   
                  edge % wB(i , IRHO) = self % q(IRHO)
                  edge % wB(i , IU  ) = self % q(IRHOU) / self % q(IRHO)
                  edge % wB(i , IV  ) = self % q(IRHOV) / self % q(IRHO)
                  edge % wB(i , IP  ) = thermodynamics % gm1 * ( self % q(IRHOE) - 0.5_RP * ( edge % wB(i,IU) * edge % uB(i,IRHOU) + edge % wB(i,IV) * edge % uB(i,IRHOV) ) ) 
                  edge % wB(i , IT  ) = edge % wB(i , IP) / edge % wB(i , IRHO)
                  edge % wB(i , IA  ) = sqrt( thermodynamics % gamma * edge % wB(i,IT) )

#ifdef NAVIER_STOKES
                  edge % gB(i , 1:NDIM , 1:NGRAD) = 0.0_RP
#endif
               end do

         end select
         end associate

      end subroutine DirichletBC_Associate

