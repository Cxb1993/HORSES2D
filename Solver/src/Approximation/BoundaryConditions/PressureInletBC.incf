!
!///////////////////////////////////////////////////////////////////////////////////
!
!           PRESSURE INLET BC
!           -----------------
!///////////////////////////////////////////////////////////////////////////////////
!
      subroutine PressureInletBC_Construct( self , marker , in_label)
         use Setup_class
         implicit none
         class(PressureInletBC_t)      :: self
         integer                   :: marker
         character(len=*)          :: in_label
         real(kind=RP), allocatable             :: pressure
         real(kind=RP), allocatable         :: Temperature
         real(kind=RP), allocatable         :: Mach
         real(kind=RP), allocatable         :: AngleOfAttack
         real(kind=RP)                          :: rho

         call readValueInRegion( trim(Setup % bdry_file) , "pressure" , pressure , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Temperature", Temperature , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Mach" , Mach , in_label , "# end")
         call readValueInRegion( trim(Setup % bdry_file) , "Angle of attack" , AngleOfAttack , in_label , "# end")
         
         if ( allocated(pressure) ) then
            pressure = pressure / refValues % p
         else
            allocate(pressure)
            pressure = 1.0_RP
         end if

         if ( allocated(Temperature) ) then
            Temperature = Temperature / refValues % T
         else
            allocate(Temperature)
            Temperature = 1.0_RP
         end if

         if ( .not. allocated(Mach) ) then
            allocate(Mach)
            Mach = Dimensionless % Mach
         end if

         if ( allocated(AngleOfAttack) ) then
            AngleOfAttack = AngleOfAttack * PI / 180.0_RP
         else
            allocate(AngleOfAttack)
            AngleOfAttack = 0.0_RP
         end if
!
!        Construct the state vector
!        --------------------------
         associate ( gamma => Thermodynamics % Gamma , cv => Dimensionless % cv , gm1 => Thermodynamics % gm1 , gogm1 => Thermodynamics % gogm1 )
         rho = pressure / Temperature
         self % q(IRHO) = rho
         self % q(IRHOU) = rho * sqrt(gamma) * Mach * cos(AngleOfAttack)
         self % q(IRHOV) = rho * sqrt(gamma) * Mach * sin(AngleOfAttack)
         self % q(IRHOE) = cv * pressure + 0.5_RP * rho * gamma * Mach * Mach
         self % AngleOfAttack = AngleOfAttack
         self % Tt            = Temperature * ( 1.0_RP + 0.5_RP * gm1 * Mach * Mach)
         self % pt            = pressure * ( self % Tt / Temperature ) ** gogm1 
         self % rhot          = rho * ( self % pt / pressure ) ** (1.0_RP / gamma)
         self % st            = self % pt / (self % rhot) ** gamma
         self % Ht            = Temperature * Dimensionless % cp + 0.5_RP * gamma * Mach * Mach
         end associate

      end subroutine PressureInletBC_Construct

      subroutine PressureInletBC_Associate(self , edge)
         implicit none
         class(PressureInletBC_t)          :: self
         class(Edge_t)                 :: edge

         associate ( N=> edge % spA % N )
         select type ( edge )
            type is (StraightBdryEdge_t)
               allocate ( edge % FB ( 0:N , 1:NCONS ) )
               allocate ( edge % uB ( 0:N , 1:NCONS ) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               edge % wB(0:,1:)    => edge % storage(1) % W(0:,1:)
#ifdef NAVIER_STOKES
               edge % gB(0:,1:,1:) => edge % storage(1) % dQ(0:,1:,1:)
#endif

            type is (CurvedBdryEdge_t)
               allocate ( edge % FB ( 0:N , 1:NCONS ) )
               allocate ( edge % uB ( 0:N , 1:NCONS ) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

               edge % wB(0:,1:)    => edge % storage(1) % W(0:,1:)
#ifdef NAVIER_STOKES
               edge % gB(0:,1:,1:) => edge % storage(1) % dQ(0:,1:,1:)
#endif

        end select
        end associate

      end subroutine PressureInletBC_Associate

      subroutine PressureInletBC_UpdateSolution( self , edge )
         implicit none
         class(PressureInletBC_t) :: self
         class(Edge_t)            :: edge
         integer                  :: iXi
         integer                  :: N
         real(kind=RP)            :: rhoL , vnL , uL , vL , pL , ML , aL  , TL
         real(kind=RP)            :: rhoR , vnR , uR , vR , pR , VtR , TR , aR , MR
         real(kind=RP)            :: a , b , c , rhostar
         real(kind=RP)            :: Rplus
         real(kind=RP)            :: q(NCONS) , F(NCONS,NDIM)
!
!        *********************************************************************
!           This routine computes the "Right" state of a InflowOutflow boundary
!          condition. Once this is done, the Riemann flux is computed
!          from the computed state, and the real boundary state. This
!          ficticial state is computed by means of the characteristics method
!          which yields in four cases:
!              * Supersonic inflow (Four entering characteristics)
!              * Subsonic inflow (Three entering characteristics)
!              * Subsonic outflow (One entering characteristics)
!              * Supersonic outflow (All characteristics leave the domain)
!        *********************************************************************
!
         associate ( gamma => Thermodynamics % gamma , gm1 => Thermodynamics % gm1 , cp => Dimensionless % cp , cv => Dimensionless % cv)


         N = edge % spA % N

         select type ( edge )
            type is (StraightBdryEdge_t) 
               do ixi = 0 , n
!
!                 first stage: determine the boundary flow character
!                 --------------------------------------------------
                  rhol = edge % storage(1) % q(ixi , irho)
                  ul  = edge % storage(1) % q(ixi , irhou) / rhol
                  vl  = edge % storage(1) % q(ixi , irhov) / rhol
                  vnl = ul * edge % n (ix , ixi) + vl * edge % n(iy, ixi)
                  pl  = gm1 * ( edge % storage(1) % q(ixi , irhoe) - 0.5_rp * edge % storage(1) % q(ixi,irhou) * ul - 0.5_rp * edge % storage(1) % q(ixi,irhov) * vl )
                  al  = sqrt( gamma * pl / rhol ) 
                  tl  = pl / rhol
                  ml  = vnl / al
                  rplus = vnl + 2.0_rp * dimensionless % cv * al
!
!                 second stage: compute the "right" state depending on the result
!                 ---------------------------------------------------------------
                  if ( ml .lt. -1.0_rp ) then      ! supersonic inflow
                     q = self % q
                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
               
                  elseif ( ml .le. 0.0_rp ) then   ! subsonic inflow
                     a = self % st * (gamma+1.0_rp) / gm1
                     b = -2.0_rp / gamma * sqrt(gamma * self % st) * rplus
                     c = rplus*rplus / (2.0_rp * cp) - self % tt

                     rhostar = (-b + sqrt(b*b - 4.0_rp * a * c))/(2.0_rp * a)
                     rhor = rhostar ** ( 2.0_rp * cv ) 
                     pr   = self % st * (rhor ** ( gamma ) )
                     ar   = sqrt(gamma * pr / rhor)
                     vnr  = abs(rplus - 2.0_rp * cv * ar)
                     ur   = -vnr * edge % n(ix,ixi)
                     vr   = -vnr * edge % n(iy,ixi)

                     q(irho) = rhor
                     q(irhou) = q(irho) * ur
                     q(irhov) = q(irho) * vr
                     q(irhoe) = cv * pr + 0.5_rp * (q(irhou) * ur + q(irhov) * vr )

                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
 
                     
                  elseif ( ml .lt. 1.0_rp ) then   ! subsonic outflow

                      pr = 2.0_rp * self % pt - pl
                      ur = ul
                      vr = vl
                      rhor = rhol

                      q(irho) = rhor
                      q(irhou) = rhor * ur
                      q(irhov) = rhor * vr
                      q(irhoe) = cv * pr + 0.5_rp * (q(irhou) * ur + q(irhov) * vr )

                      f = inviscidflux( q )
                      edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)


                  elseif ( ml .ge. 1.0_rp ) then   ! supersonic outflow
                  
                     q = edge % storage(1) % q(ixi,1:ncons)
                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
      
                  end if

                  edge % ub(ixi,1:ncons) = q
      
               end do 

            type is (CurvedBdryEdge_t) 

               do ixi = 0 , n
!
!                 first stage: determine the boundary flow character
!                 --------------------------------------------------
                  rhol = edge % storage(1) % q(ixi , irho)
                  ul  = edge % storage(1) % q(ixi , irhou) / rhol
                  vl  = edge % storage(1) % q(ixi , irhov) / rhol
                  vnl = ul * edge % n (ix , ixi) + vl * edge % n(iy, ixi)
                  pl  = gm1 * ( edge % storage(1) % q(ixi , irhoe) - 0.5_rp * edge % storage(1) % q(ixi,irhou) * ul - 0.5_rp * edge % storage(1) % q(ixi,irhov) * vl )
                  al  = sqrt( gamma * pl / rhol ) 
                  tl  = pl / rhol
                  ml  = vnl / al
                  rplus = vnl + 2.0_rp * dimensionless % cv * al
!
!                 second stage: compute the "right" state depending on the result
!                 ---------------------------------------------------------------
                  if ( ml .lt. -1.0_rp ) then      ! supersonic inflow
                     q = self % q
                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
               
                  elseif ( ml .le. 0.0_rp ) then   ! subsonic inflow
                     a = self % st * (gamma+1.0_rp) / gm1
                     b = -2.0_rp / gamma * sqrt(gamma * self % st) * rplus
                     c = rplus*rplus / (2.0_rp * cp) - self % tt

                     rhostar = (-b + sqrt(b*b - 4.0_rp * a * c))/(2.0_rp * a)
                     rhor = rhostar ** ( 2.0_rp * cv ) 
                     pr   = self % st * (rhor ** ( gamma ) )
                     ar   = sqrt(gamma * pr / rhor)
                     vnr  = abs(rplus - 2.0_rp * cv * ar)
                     ur   = -vnr * edge % n(ix,ixi)
                     vr   = -vnr * edge % n(iy,ixi)

                     q(irho) = rhor
                     q(irhou) = q(irho) * ur
                     q(irhov) = q(irho) * vr
                     q(irhoe) = cv * pr + 0.5_rp * (q(irhou) * ur + q(irhov) * vr )

                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
 
                     
                  elseif ( ml .lt. 1.0_rp ) then   ! subsonic outflow

                      pr = 2.0_rp * self % pt - pl
                      ur = ul
                      vr = vl
                      rhor = rhol

                      q(irho) = rhor
                      q(irhou) = rhor * ur
                      q(irhov) = rhor * vr
                      q(irhoe) = cv * pr + 0.5_rp * (q(irhou) * ur + q(irhov) * vr )

                      f = inviscidflux( q )
                      edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)


                  elseif ( ml .ge. 1.0_rp ) then   ! supersonic outflow
                  
                     q = edge % storage(1) % q(ixi,1:ncons)
                     f = inviscidflux( q )
                     edge % fb(ixi,1:ncons) = f(1:ncons,ix) * edge % ds(ix,ixi) + f(1:ncons , iy) * edge % ds(iy,ixi)
      
                  end if

                  edge % ub(ixi,1:ncons) = q
      
               end do 

            class default
         end select

         end associate

      end subroutine PressureInletBC_UpdateSolution
