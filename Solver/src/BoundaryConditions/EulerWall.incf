!
!///////////////////////////////////////////////////////////////////////////////////
!
!           EULER WALL
!           ----------
!///////////////////////////////////////////////////////////////////////////////////
!
      subroutine EulerWall_Associate( self , edge ) 
         implicit none  
         class(EulerWall_t)                  :: self
         class(Edge_t)                       :: edge

         associate( N => edge % spA % N )
         select type ( edge )
         
            type is (Edge_t)
               print*, "Only boundary edges are expected."
               stop "Stopped"

            type is (StraightBdryEdge_t)
               allocate( edge % FB(0:N,NCONS) )
               allocate( edge % uB(0:N,NCONS) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

#ifdef NAVIER_STOKES
               allocate( edge % gB(0:N,1:NDIM,1:NGRAD) )
#endif
 
            type is (CurvedBdryEdge_t)
               allocate( edge % FB(0:N,NCONS) )
               allocate( edge % uB(0:N,NCONS) )

               edge % BCWeakType = self % WeakType

               edge % RiemannSolver => self % RiemannSolver

#ifdef NAVIER_STOKES
               allocate( edge % gB(0:N,1:NDIM,1:NGRAD) )
#endif

            class default
         end select
         end associate
                
      end subroutine EulerWall_Associate


      subroutine EulerWall_UpdateSolution( self , edge )
         implicit none  
         class(EulerWall_t)                  :: self
         class(Edge_t)                       :: edge
         real(kind=RP)                       :: q(NCONS) , F(NCONS,NDIM)
         real(kind=RP)                       :: rhovn , rhovt
         real(kind=RP)                       :: p
         integer                             :: iXi
         
         associate( N => edge % spA % N , gm1 => Thermodynamics % gm1 , gamma => Thermodynamics % gamma , Mach => Dimensionless % Mach )
   
         select type ( edge ) 
            type is (StraightBdryEdge_t)

               do iXi = 0 , N
!
!                 The flux is computed by substracting the normal velocity to the interior state. Pressure and density are gathered from the interior
!                 -----------------------------------------------------------------------------------------------------------------------------------
                  rhovn = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IX,iXi) + edge % storage(1) % Q(iXi,IRHOV) * edge % n(IY,iXi) )
                  rhovt = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IY,iXi) - edge % storage(1) % Q(iXi,IRHOV) * edge % n(IX,iXi) )
                  p     = gm1 * (edge % storage(1) % Q(iXi,IRHOE) - 0.5_RP * (edge % storage(1) % Q(iXi,IRHOU)*edge % storage(1) % Q(iXi,IRHOU) + edge % storage(1) % Q(iXi,IRHOV) * edge % storage(1) % Q(iXi,IRHOV)) / edge % storage(1) % Q(iXi,IRHO))

                  q(IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  q(IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - rhovn * edge % n(IX,iXi)
                  q(IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - rhovn * edge % n(IY,iXi)
                  q(IRHOE) = Dimensionless % cv * p + 0.5_RP * rhovt * rhovt / edge % storage(1) % Q(iXi,IRHO)
!
!                 Compute the fluxex from the built state
!                 ---------------------------------------
                  F = inviscidFlux( q )
!
!                 Compute the normal flux
!                 -----------------------
                  edge % FB(iXi,1:NCONS) = (F(1:NCONS,IX) * edge % n(IX,iXi) + F(1:NCONS,IY) * edge % n(IY,iXi)) * edge % dS(iXi)
!
!                 Compute the variables state
!                 ---------------------------
                  edge % uB(iXi,IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  edge % uB(iXi,IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - 2.0_RP * rhovn * edge % n(IX,iXi)
                  edge % uB(iXi,IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - 2.0_RP * rhovn * edge % n(IY,iXi)
                  edge % uB(iXi,IRHOE) = edge % storage(1) % Q(iXi,IRHOE)

               end do
                  
         
            type is (CurvedBdryEdge_t)

               do iXi = 0 , N
!
!                 The flux is computed by substracting the normal velocity to the interior state. Pressure and density are gathered from the interior
!                 -----------------------------------------------------------------------------------------------------------------------------------
                  rhovn = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IX,iXi) + edge % storage(1) % Q(iXi,IRHOV) * edge % n(IY,iXi) )
                  rhovt = (edge % storage(1) % Q(iXi,IRHOU) * edge % n(IY,iXi) - edge % storage(1) % Q(iXi,IRHOV) * edge % n(IX,iXi) )
                  p     = gm1 * (edge % storage(1) % Q(iXi,IRHOE) - 0.5_RP * (edge % storage(1) % Q(iXi,IRHOU)*edge % storage(1) % Q(iXi,IRHOU) + edge % storage(1) % Q(iXi,IRHOV) * edge % storage(1) % Q(iXi,IRHOV)) / edge % storage(1) % Q(iXi,IRHO))

                  q(IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  q(IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - rhovn * edge % n(IX,iXi)
                  q(IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - rhovn * edge % n(IY,iXi)
                  q(IRHOE) = Dimensionless % cv * p + 0.5_RP * rhovt * rhovt / edge % storage(1) % Q(iXi,IRHO)
!
!                 Compute the fluxex from the built state
!                 ---------------------------------------
                  F = inviscidFlux( q )
!
!                 Compute the normal flux
!                 -----------------------
                  edge % FB(iXi,1:NCONS) = (F(1:NCONS,IX) * edge % n(IX,iXi) + F(1:NCONS,IY) * edge % n(IY,iXi)) * edge % dS(iXi)
!
!                 Compute the variables state
!                 ---------------------------
                  edge % uB(iXi,IRHO)  = edge % storage(1) % Q(iXi,IRHO)
                  edge % uB(iXi,IRHOU) = edge % storage(1) % Q(iXi,IRHOU) - 2.0_RP * rhovn * edge % n(IX,iXi)
                  edge % uB(iXi,IRHOV) = edge % storage(1) % Q(iXi,IRHOV) - 2.0_RP * rhovn * edge % n(IY,iXi)
                  edge % uB(iXi,IRHOE) = edge % storage(1) % Q(iXi,IRHOE)

               end do
                  
 
            class default
         end select

         end associate

      end subroutine EulerWall_UpdateSolution

#ifdef NAVIER_STOKES 
      subroutine EulerWall_UpdateGradient( self , edge )
         implicit none  
         class(EulerWall_t)                  :: self
         class(Edge_t)                       :: edge
!
!        ***************************************************
!           For each edge the ghost cell state is computed as
!              UB(IRHO) = Q(IRHO)
!              UB(IRHOU) = -Q(IRHOU)
!              UB(IRHOV) = -Q(IRHOV)
!              UB(IRHOE) = Q(IRHOE)
!
!           The primitive variables are set as follows:
!              WB(IU) = 0
!              WB(IV) = 0
!              WB(IT) = Tint / Text (Adiabatic/Isothermal)
!
!           The gradients are set such that the stresses are
!           computed from the inner flow, while the temperature
!           flux is:
!                 dT = dTi for Isothermal
!                 dT = -dTi for Adiabatic
!        ***************************************************
!
         associate( N => edge % spA % N )
   
         select type ( edge ) 
            type is (StraightBdryEdge_t)
   
               edge % gB(0:N , 1:NDIM , IGU) = edge % storage(1) % dQ(0 : N , 1:NDIM , IGU)
               edge % gB(0:N , 1:NDIM , IGV) = edge % storage(1) % dQ(0 : N , 1:NDIM , IGV)

!               if ( self % wall_type .eq. ISOTHERMAL_WALL ) then
!                  edge % gB( 0:N , 1:NDIM , IGT ) = edge % storage(1) % dQ( 0:N , 1:NDIM , IGT)
!
!               elseif ( self % wall_type .eq. ADIABATIC_WALL ) then
                  edge % gB( 0:N , 1:NDIM , IGT ) = -edge % storage(1) % dQ( 0:N , 1:NDIM , IGT)
!
!               end if

            type is (CurvedBdryEdge_t)


               edge % gB(0:N , 1:NDIM , IGU) = edge % storage(1) % dQ(0 : N , 1:NDIM , IGU)
               edge % gB(0:N , 1:NDIM , IGV) = edge % storage(1) % dQ(0 : N , 1:NDIM , IGV)

!               if ( self % wall_type .eq. ISOTHERMAL_WALL ) then
!                  edge % gB( 0:N , 1:NDIM , IGT ) = edge % storage(1) % dQ( 0:N , 1:NDIM , IGT)
!
!               elseif ( self % wall_type .eq. ADIABATIC_WALL ) then
                  edge % gB( 0:N , 1:NDIM , IGT ) = -edge % storage(1) % dQ( 0:N , 1:NDIM , IGT)

!               end if

            class default
         end select

         end associate

      end subroutine EulerWall_UpdateGradient
#endif
